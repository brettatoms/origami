(ns opencv4.video
  (:import
    [org.opencv.core Mat Core CvType]
    [org.opencv.videoio Videoio VideoCapture]
    [org.opencv.video Video]))


(declare new-videocapture)
(declare debug-device)

(defn- key-to-prop-s [k]
    (let [ks (name k) prop (str "CAP_PROP_" (clojure.string/upper-case (clojure.string/replace ks  "-" "_")))]
    (str "org.opencv.videoio.Videoio/" prop)))

(defn- key-to-prop [k]
  (eval (read-string (key-to-prop-s k))))

(defn capture-device [ video ]
  (let [capture (new-videocapture) video-map (if (map? video) video (read-string (slurp video))) ]
      (let [debug? (dissoc video-map :debug) settings (keys (dissoc video-map :debug :device)) ]
        (doseq [s settings]
            (.set capture (key-to-prop s) (-> video-map s)))
      (.open capture (-> video-map :device))
      (if debug? (debug-device capture))
  capture)))

(defn debug-device [capture video-map]
(let[ cam-keys 
    (->> (ns-map 'opencv4.video)
    (keys)
    (map str)
    (filter #(clojure.string/includes? % "CAP_PROP_") )
    (map #(second (clojure.string/split % #"CAP_PROP_")))
    (map #(clojure.string/lower-case %))
    (map #(clojure.string/replace %  "_" "-"))
    (map keyword))
    ;in (keys video-map)
    ] 
    (println "- - - - - - [" (:device video-map) "] - - - - - -")
    (doseq [k cam-keys]
    (let [v (.get capture (key-to-prop k))]
      (if (not (and (= 0.0 v) (= -1.0 v)))
        (println 
          (if (contains? video-map k) "* " "  ") 
            k  ":" v 
          (if (contains? video-map k) (str " [" (video-map k) "]" )) ))))))